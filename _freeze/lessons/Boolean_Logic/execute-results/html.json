{
  "hash": "9810c3dc8d81bf1c069f76b69731def2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nformat: html\nfilters:\n- panelize\n- pyodide\ntitle: Truth & Conditions\n---\n\n\n\n\nIn this lesson we'll learn how to compare stuff (like numerical quantities but also words and strings) via *Comparison Operators*. \n\nWe'll also see how to express logical concepts like: \" `if` this condition is `True`, then do something...\". These concepts will enable your code account for different possibilities and let it run to accordingly. They will also serve to perform assertions and to test if certain conditions have been met or not.\n\n## Booleans\nThe most basic form of comparison is to test if something is `True` of `False`. To do so we'll have to quickly introduce another *data type*, the **boolean**. \n\nBooleans are different from the numerical (*floats* and *integers*) or textual (*strings*) data types that we have seen so far because they have only two possible values: `True` or `False`.\n\n```{pyodide-python}\nmyBoolean = True\nprint(myBoolean)\nprint(\"This statement is: '\" + str(myBoolean) + \"'\")\n```\n\n::: {.callout-tip}\n\nDid you see the `str()` around the `myBoolean` variable on the second `print` line? That's so that we can print out its value as part of a string. If you just tried `print(\"This statement is: \" + myBoolean)` you'd get a `TypeError` because you can't concatentate (join together with a `+`) a string and a boolean. For more on errors see the lesson on [exceptions](Exceptions.qmd).\n\n:::\n\n## Comparisons\n\nHow do we use booleans? Well, what if I ask you \"Is it true or false that an elephant is bigger than a mouse?\" So we use booleans why making some kind of *comparison* between two things: is it bigger? is it smaller? is the same?\n\n::: {.callout-note}\n\nNote: just so that you know, sometimes people will use `1` and `0` in place of `True` and `False` because that's what's actually happening behind the scenes. It's the same thing _logically_ , but Python views `True` and `False` differently from `1` and `0` because the latter are numbers, while the former are truth values (thus, the _boolean_ data type).\n\n:::\n\nYou will need these set of operators:\n\n| Operator  | Meaning            | Example                                                        |\n|:----------|:-------------------|:---------------------------------------------------------------|\n| `>`        | Greater Than       | `A>B` returns `True` if value of `A` is larger than value of `B` |\n| `<`         | Less Than          | `A<B` returns `True` if value of `A` is smaller than value of `B` |\n| `>=`        | Greater Equal Than | `A>=B` returns `True` if value of `A` is larger than or equal to value of `B` |\n| `<=`        | Less Equal Than    | `A<=B` returns `True` if value of `A` is smaller than or equal to value of `B` |\n| `==` | Equal To | `A==B` returns `True` if value of `A` is exactly equal to value of `B` |\n\nHere's an initial example (without a print statement):\n\n```{pyodide-python}\n25 > 7\n```\n\nAnd further examples (with print statements):\n\n:::{.to-pyodide}\n\n::: {#1d59e8f4 .cell execution_count=1}\n``` {.python .cell-code}\nprint(7  >= 7)\nprint(7  >  7)\nprint(25 <= 7)\nprint(25 <= 25.0)\nprint(25 <  25.0)\nprint(25 <  25.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n```\n:::\n:::\n\n\n:::\n\nNumerical comparisons are fairly straightforward, and you'll see that Python automatically does fairly sensible things:\n\n- Because it converts automatically between integers and floats, `25` and `25.0` are evaluated properly\n- As are 25 and 25.1 because the 'casting' of integers to floats turns `25` into `25.0` automatically\n\nBut here are some slightly more complicated examples involving _string_ comparisons:\n\n:::{.to-pyodide}\n\n::: {#7faa60af .cell execution_count=2}\n``` {.python .cell-code}\nprint(\"\\nA 'simple' string comparison:\")\nprint(\"A\" > \"B\")\nprint(\"B\" > \"A\")\n\nprint(\"\\nSomething slightly trickier:\")\nprint(\"A\" >  \"a\")\nprint(\"A\" >= \"a\")\nprint(\"A\" <  \"a\")\n\nprint(\"\\nAnd trickier again:\")\nprint(\"ab\" < \"abc\")\n\nprint(\"\\nhmmmm...\")\nprint(\"James\" < \"Jane\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nA 'simple' string comparison:\nFalse\nTrue\n\nSomething slightly trickier:\nFalse\nFalse\nTrue\n\nAnd trickier again:\nTrue\n\nhmmmm...\nTrue\n```\n:::\n:::\n\n\n:::\n\nWhy does Python think 'A' is less than 'a', and 'Aardvark' is less than 'Ant'?\n\nWhen comparing `str` objects, Python uses character _unicodes_. [Unicode](https://www.unicode.org/) is a specification that aims to list every character used by human languages and give each character its own unique 'number'. In Python, these codes are of type `int`. \n\nTo see this in action, we can use the `ord` function to get Python to show us the unicode for a single character:\n\n:::{.to-pyodide}\n\n::: {#6fdf4d0a .cell execution_count=3}\n``` {.python .cell-code}\nprint(ord(\"A\"))\nprint(ord(\"a\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n65\n97\n```\n:::\n:::\n\n\n:::\n\nHopefully this output helps you to see why `print(\"A\" > \"a\")` returns `False`\n\nWhen there are multiple characters in a `string` object, Python compares each character in order. Suppose, as we do above, we have `str1` as \"James\"  and `str2` as \"Jane\". The first two characters from `str1`  and `str2` (J and J) are compared. Because they are equal, the second two characters are compared. Because they are also equal, the third two characters (m and n) are compared. And because m has smaller unicode value than n, `str1` is less than `str2`.\n\n:::{.to-pyodide}\n\n::: {#02d05a1d .cell execution_count=4}\n``` {.python .cell-code}\nstr1 = \"James\"\nstr2 = \"Jane\"\n\n# compare\nprint(str1 < str2)\n\n# proof\nprint(ord(\"m\"))\nprint(ord(\"n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n109\n110\n```\n:::\n:::\n\n\n:::\n\nHopefully this helps you to see why `print(\"James\" < \"Jane\")` returns `True`\n\n### A challenge for you!\n\nIn the next two challenges, we've deliberately left out or broken some code that _you_ need to fix!\n\nFix this code so that it returns `True`\n\n::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\nfirst_variable = 87.0\nsecond_variable = 9\n\nprint(first_variable % 80 ??? second_variable)\n```\n\n#### Answer\n\n::: {#0a64b1ce .cell execution_count=5}\n``` {.python .cell-code}\nfirst_variable = 87.0\nsecond_variable = 9\n\nprint(first_variable % 80 < second_variable)\n\n# proof\nprint(first_variable % 80)\nprint(second_variable)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n7.0\n9\n```\n:::\n:::\n\n\n:::\n\nFix this code so that it returns `False`\n\n::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\nprint(\"Aardvark\" ??? \"Ant\")\n```\n\n#### Answer\n\n::: {#ea3c1563 .cell execution_count=6}\n``` {.python .cell-code}\nprint(\"Aardvark\" > \"Ant\")\n\n# proof\nprint(ord(\"a\"))\nprint(ord(\"n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n97\n110\n```\n:::\n:::\n\n\n:::\n\n## Equality\n\nSo we've seen the comparison operators that you probably still remember from high-school maths. But sometimes we don't want to test for _difference_, we want to test if two things are _the same_. In your maths class you probably just wrote $$x = y$$ and moved on to the next problem, but remember: one equals sign is already being used to assign values to variables! As in:\n\n::: {#dacaf287 .cell execution_count=7}\n``` {.python .cell-code}\nmy_var = 1\n```\n:::\n\n\nTo test if something is exactly equal we use the *equality comparison operator*, which is two equals signs together ($==$). This equality comparison returns `True` if the contents of two variables/results of two calculations are equal. That's a bit of a mouthful, but all we're saying is that we compare the left-hand side (LHS) of the equality operator ($==$) with the right-hand side (RHS) to see if they evaluate to the same answer.\n\nA _lot_ of new programmers make the mistake of writing `=` in their code when they wanted `==`, and it can be hard to track this one down. So always ask yourself: am I comparing two things, or assigning one to the other?\n\nRun the following code and check you understand why the output produced is as it is.\n\n:::{.to-pyodide}\n\n::: {#ef39dfae .cell execution_count=8}\n``` {.python .cell-code}\n# This (=) assigns a value to a variable\nbritish_capital = \"London\"\nfrench_capital  = \"Paris\"\n\n# This (==) compares two variables\nprint(british_capital == french_capital)\n\n# This is probably a mistake\nbritish_capital = french_capital\nprint(british_capital)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nParis\n```\n:::\n:::\n\n\n:::\n\n### A challenge for you!\n\nBefore you run the code in each cell, try to think through what _you_ expect each one to print out!\n\n:::{.panel-tabset}\n\n#### Question \n\n```{pyodide-python}\n# Is this True?\n2 == 34\n```\n\n#### Answer\n\n::: {#44f32acf .cell execution_count=9}\n``` {.python .cell-code}\n# Is this True?\n2 == 34\n```\n\n::: {.cell-output .cell-output-display execution_count=233}\n```\nFalse\n```\n:::\n:::\n\n\n:::\n\n::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\n# How about this?\n7 == 7\n```\n\n```python\n# How about this?\n7 == \"7\"\n```\n\n```{pyodide-python}\n# And this?\n\"Foo\" == \"Bar\"\n```\n\n#### Answer\n\n::: {#fd4db2eb .cell execution_count=10}\n``` {.python .cell-code}\n# How about this?\n7 == 7\n```\n\n::: {.cell-output .cell-output-display execution_count=234}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#f982764b .cell execution_count=11}\n``` {.python .cell-code}\n# How about this?\n7 == \"7\"\n```\n\n::: {.cell-output .cell-output-display execution_count=235}\n```\nFalse\n```\n:::\n:::\n\n\n::: {#3b5e5e26 .cell execution_count=12}\n``` {.python .cell-code}\n# And this?\n\"Foo\" == \"Bar\"\n```\n\n::: {.cell-output .cell-output-display execution_count=236}\n```\nFalse\n```\n:::\n:::\n\n\n:::\n\n::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\n# And this?\n10 % 3 == 3 / 3\n```\n\n#### Answer\n\n::: {#d6a893b3 .cell execution_count=13}\n``` {.python .cell-code}\n# This may help...\nprint(10 % 3)\nprint(3 / 3)\nprint(10 % 3 == 3/3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n1.0\nTrue\n```\n:::\n:::\n\n\n:::\n\n### Inequality\n\nWhat if you want to check if two things are *different* rather than equal? Well then you'll need to use the *Not Equal* ($!=$) operator, which returns `True` when there's no equality between the conditons you are comparing. \n\nCheck you understand the output when running the following code\n\n::: {#9f2988f6 .cell execution_count=14}\n``` {.python .cell-code}\n# Reset the variables to their 'defaults'\nbritish_capital = \"London\"\nfrench_capital  = \"Paris\"\n\n# This time python is going to print True,\n# since we are comparing different things\n# using the Not Equal operator! This may\n# show to you as an equals sign with a \n# slash through it, but it's typed as \n# '!' + '=' (!=)\nprint(british_capital != french_capital)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nTry it yourself:\n\n```{pyodide-python}\nprint(\"Foo\" != \"Bar\")\n```\n\n## Conditions\n\nOK, so now we've seen comparisons and booleans, but why? Where are we going with this? Think back to the first lesson and the example of what is happening inside a computer: _if_ the user has clicked on the mouse _then_ we need to do something (e.g. change the colour of the button, open the web link, etc.). Everything that we've done up until now basically happened on a single line: _set_ this variable, _set_ that variable, print out the result of the _comparison_. \n\nNow we're going to step it up a level.\n\nTo check a condition you will need to use a *statement* (i.e. [everything that makes up one or more lines of code line](https://stackoverflow.com/questions/4728073/what-is-the-difference-between-an-expression-and-a-statement-in-python) ) to see `if` that condition is True/False, in which case do one thing, or `else` do something else...\n\nLet's see that in action!\n\n### If...\n\nLet's start with a basic `if` statement. In Python you write it:\n\n```python\nif conditon-to-check:\n   statement\n```\n\nSo an `if` condition starts with the word `if` and ends with a colon (`:`).\n\nThe statement is the code that we want the computer to run _if_ the `condition-to-check` comes out `True`. **However**, notice that the next line – the `statement` line – is indendented. This is Python's way to define a *block of code*. \n\nA **block of code** means that we can run several lines of code _if_ the condition is True. As long as the code is indented then Python will treat it as code to run _only_ if the condition is True.\n\nLet's see a few examples. Run the following code cell and see if you can understand the output produced (given the code in the cell).\n\n:::{.to-pyodide}\n\n::: {#e4417097 .cell execution_count=15}\n``` {.python .cell-code}\n# Condition 1\nif 2 > 1:\n    print(\"> Condition #1\")\n    \n# Condition 2\nif 1 > 2: \n    print(\"> Condition #2\")\n    \n# Condition 3\nif \"Foo\" == \"Foo\":\n    print(\"> Condition #3\")\n    myVar = 1 + 5\n    print(\"     My var: \" + str(myVar))\n    \n# Condition 4\nif \"Foo\" != \"Foo\":\n    print(\"> Condition #4\")\n    myVar = 1 + 5\n    print(\"     My var: \" + str(myVar))\n    \nprint(\"Done.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n> Condition #1\n> Condition #3\n     My var: 6\nDone.\n```\n:::\n:::\n\n\n:::\n\nSee how that works? Only conditions \\#1 and \\#3 were printed out, \\#2 and \\#4 were skipped over entirely!\n\nLet's take these in order:\n\n1. 2 _is_ greater than 1, so the `condition-to-check` returns True and Python then looks at the next line to see what it should do next.\n2. 1 _is not_ greater than 2, so the `condition-to-check` returns False. Python then skips the next _two_ indented lines which form part of the _code block_. It's the indentation that tells Python they're still part of the same code block. That _entire code block_ would only be executed _if_ the `condition-to-check` had been True.\n3. \"Foo\" is the same as \"Foo\", so this condition is True. Python then runs the next three lines because the indentation tells Python that they are all part of the same code block. Notice that we can even do things like set new variables in a code block.\n4. \"Foo\" is _still_ the same as \"Foo\", but we were testing if they were _not equal_ (`!=`) and so this condition is False. This time Python skips over the three lines and moves straight to the last print statement.\n5. Notice that the last print (`\"Done.\"`) always runs, no matter what the previous conditions were, because it is _not indented_ and so is not part of a _code block_.\n\nLet's see another example (run the code and check you understand the result)\n\n:::{.to-pyodide}\n\n::: {#6edb19b5 .cell execution_count=16}\n``` {.python .cell-code}\nlondon_population = 8600000\nparis_population  = 2200000 \n\nif london_population > paris_population:\n    print(\"London is larger than Paris\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLondon is larger than Paris\n```\n:::\n:::\n\n\n:::\n\nNote: Other languages such as C/C++ use curly braces `{...}` around a block, just in case you find other languages in examples when Googling for help.\n\n::: {.callout-warning}\n\n#### Indents vs. Tabs\n\nHow much should you indent? Although the [official specification](https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces) specifies *4 spaces*, quite a few people indent using *one tab* instead. Technically, there is no difference _as long as you are consistent_ (See [this discussion](http://stackoverflow.com/questions/1125653/python-4-whitespaces-indention-why)). This apparently trivial issue is the sort of thing that leads to all kinds of heated argument (like whether you prefer Mac OSX or Windows; OSX is better, obviously). It's such a famous aspect of the programming world that it even featured in an episode of the sit-com [Silicon Valley](https://en.wikipedia.org/wiki/Silicon_Valley_(TV_series)): \n\n\n\n\n{{< video https://youtu.be/cowtgmZuai0 >}}\n\n\n\n\n\n\n:::\n\nYou can, of course, do multiple comparisons one after another:\n\n:::{.to-pyodide}\n\n::: {#1729ec62 .cell execution_count=17}\n``` {.python .cell-code}\nlondon_population = 8600000\n\nif london_population > 2000000:\n    print(str(london_population) + \" is more than 2 million people\")\n\nif london_population < 10000000:\n    print(str(london_population) + \" is less than 10 million people\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8600000 is more than 2 million people\n8600000 is less than 10 million people\n```\n:::\n:::\n\n\n:::\n\nComplete the missing code, while also fixing the broken bits (_HINT:_ Remember the position of colons and indentation is important in Python!):\n\n::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\nif (london_population % 8000000) == 600000 ???\nprint(\"Good job\")\n```\n\n#### Answer\n\n::: {#68f30ca2 .cell execution_count=18}\n``` {.python .cell-code}\nif (london_population % 8000000) == 600000:\n    print(\"Good job\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGood job\n```\n:::\n:::\n\n\n:::\n\n### Else...\n\nOf course, only being able to use _if_ would be pretty limiting. Wouldn't it be handy to be able to say \"_if_ x is True: do one thing; otherwise do something else\". Well you can! When you want to run a different block of code depending on whether something is True or not, then you can use the `else` statement (_only_ following a first `if`).\n\nHere's an example:\n\n:::{.to-pyodide}\n\n::: {#777f9eaa .cell execution_count=19}\n``` {.python .cell-code}\nnewyork_population = 8400000 \n\nif london_population < newyork_population:\n    largest_city = \"New York\" \nelse:\n    largest_city = \"London\"\n    \nprint(\"The largest city is \" + largest_city)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe largest city is London\n```\n:::\n:::\n\n\n:::\n\nAs you can see from the example above, the `if: else:` statement allows us to account for multiple outcomes when checking the _logic_ of a condition. Notice how the `else` syntax is similar to the `if` statement: use the colon, and indent.\n\nAlso pay attention to the fact that not *all* of our code has run. Only the block after the `else` was run. So:\n\n- _if_ returned False (London's population is not less than that of New York)\n- So the _else_ block ran instead.\n\nThis is why the `largestCity` variable was set to \"London\" and not \"New York\". After the `if: else:` sequence the code goes back to its normal flow, and all the remaining lines will be executed.\n\nThe `if: else:` statement is like a fork in the road: you can take one road, or the other, but not both at the same time.\n\n#### A challenge for you!\n\nFix the code below so that it prints out `London's population is above my threshold`.\n\n:::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\nmythreshold = 1000000\nif london_population <= mythreshold ???\n    print(\"London's population is below my threshold\")\n???:\n    print(\"London's popuation is above my threshold\")\n```\n\n#### Answer\n\n::: {#3f24abd5 .cell execution_count=20}\n``` {.python .cell-code}\nmythreshold = 1000000\nif london_population <= mythreshold:\n    print(\"London's population is below my threshold\")\nelse:\n    print(\"London's popuation is above my threshold\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLondon's popuation is above my threshold\n```\n:::\n:::\n\n\n::::\n\n### Elif...\n\nOnce again: so far, so good. But what if you need to have multiple forks? Well, then you can use a sequence of *statements* that sounds like \"IF this happens do this, ELSE IF this second condition holds do that, ELSE IF a third condition is true perform this other ELSE do finally this...\"\n\nThe operator we are going to use is `elif`, the lazy version of `ELSE IF`.\n\n:::{.to-pyodide}\n\n::: {#7707f871 .cell execution_count=21}\n``` {.python .cell-code}\n# Like so:\nmyUpperBoundary = 12000000\nmyLowerBoundary = 2000000\n\nif london_population < myUpperBoundary:\n    print(\"London is below my upper threshold.\")\n\nelif london_population > myLowerBoundary:\n    print(\"London is above my lower threshold.\")\n\nelif london_population != 340000: \n    print(\"London population is not equal to 340,000.\")\n    \nelse:\n    print(\"How did I get here?\")\n    \nprint(\"And now back to normal code execution.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLondon is below my upper threshold.\nAnd now back to normal code execution.\n```\n:::\n:::\n\n\n:::\n\nWhy didn't the output look like this:\n\n```\nLondon is below my upper threshold.\nLondon population is not equal to 340,000.\nHow did I get here?\nAnd now back to normal code execution.\n```\n\nThis a tricky one: the _first_ thing that evaluates to `True` (that London is below the upper threshold) is the one that 'wins'. Computers are also lazy in their own way: since it found that the answer to the first `elif` was True it didn't bother to look at the second `elif` and the `else`, it _only_ ran the _one_ code block.\n\n#### A challenge for you!\n\nComplete the missing bits so that the logically correct print statement is output:\n\n:::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\nlondon_population = 10\n??? london_population <= 9:\n    print(\"First case is true\")\n??? london_population > 99: \n    print(\"Second case is true\")\n??? london_population == 4:\n    print(\"Third case is true\")\n??? print(\"Well, looks like none of the above statements were true!\")\n\nprint(\"And now back to normal code execution.\")\n```\n\n#### Answer\n\n::: {#82f716ec .cell execution_count=22}\n``` {.python .cell-code}\nlondon_population = 10\nif london_population <= 9:\n    print(\"First case is true\")\nelif london_population > 99: \n    print(\"Second case is true\")\nelif london_population == 4:\n    print(\"Third case is true\")\nelse: print(\"Well, looks like none of the above statements were true!\")\n\nprint(\"And now back to normal code execution.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWell, looks like none of the above statements were true!\nAnd now back to normal code execution.\n```\n:::\n:::\n\n\n::::\n\n## Boolean Logic\n\nBoolean logic and [Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra) have to do with _set theory_ but also lie at the heart of the modern computer! A computer works by combining `AND`, `OR`, `XOR` and `NAND` circuits to produce ever more complex calculations (see [this video](https://youtu.be/AkFi90lZmXA) and [this one](https://youtu.be/VBDoT8o4q00) if you'd appreciate an introduction to/refresher on computer hardware). Naturally, we also use this same concept a lot in programming computers!\n\n![The very logical Prof. George Boole, circa 1860](https://upload.wikimedia.org/wikipedia/commons/c/ce/George_Boole_color.jpg){fit-alt=\"George Boole\" width=50%}\n\nIn Python there are [three boolean logic opertors](https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not), these are (in ascending order of priority): `or`, `and`, and `not`.\n\nWe'll look at these in more detail in a second, but here's the 'cheat sheet':\n\n- OR: _if either A OR B are True_ then run the following code block...\n- AND: _if A AND B are True_ then run the following code block...\n- NOT: _if NOT(A) is True_ (because A is _False_) then run the following code block...\n\nIt might help you to take a look at these Venn diagrams (source: [Wikimedia Commons](https://en.wikipedia.org/wiki/File:Vennandornot.svg)) that express the same three operations in graphical form. Imagine that _x_ and _y_ are both `conditions-to-test`... The left one is _AND_ because it is only the combination of _x AND y_ that is red; the centre one is _OR_ because it represents any combination of _x OR y_ being red; the rightmost is _NOT_ because it is the opposite of _x_ that is red.\n\n![Venn](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Vennandornot.svg/640px-Vennandornot.svg.png \"Venn Diagram\")\n\nOK, let's look at it in Python.\n\n### AND \n\nThe `and` operator (just like in plain English!) is used when two conditions must both be True at the same time. So it has _two_ arguments and returns `True` if, and only if, both of them are `True`. Otherwise it returns `False`.\n\n:::{.to-pyodide}\n\n::: {#9b9de6e2 .cell execution_count=23}\n``` {.python .cell-code}\ncondition1 = 2 < 4 # True\ncondition2 = (6/3) == 2 # Also True\n\nif (condition1) and (condition2): # Both are true\n    print(\"1. Both conditions are true!\")\nelse:\n    print(\"1. Mmm... something's wrong!\")\n    \nif condition1 and 6.0/5 == 1:\n    print(\"2. Both conditions are true!\")\nelse:\n    print(\"2. Mmm... something's wrong!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1. Both conditions are true!\n2. Mmm... something's wrong!\n```\n:::\n:::\n\n\n:::\n\n### OR \n\nThe `or` operator is used when we don't care which condition is True, as long as one of them is! So if *either* (or *both*!) conditions are `True`, then the operator returns `True`. Only if _both_ are `False` does it evalute to  `False`.\n\n:::{.to-pyodide}\n\n::: {#52aba861 .cell execution_count=24}\n``` {.python .cell-code}\ncondition1 = 2 < 4 # True\ncondition2 = (6/3) != 2 # False\n\nif (condition1) or (condition2):\n    print(\"1. Both conditions are true!\")\nelse:\n    print(\"1. Mmm... something's wrong!\")\n\nif 2 > 4 and 6.0/5 == 1:\n    print(\"2. Both conditions are true!\")\nelse:\n    print(\"2. Mmm... something's wrong!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1. Both conditions are true!\n2. Mmm... something's wrong!\n```\n:::\n:::\n\n\n:::\n\n### A challenge for you!\n\nTry to change the values of conditions and see the different outcomes, but first you'll need to fix the Syntax Errors and the Exceptions!\n\n::::{.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\ncondition1 = 2 < 4\ncondition2 ??? (6/3) != 2\n\nif (condition1) ??? (condition2):\n    print(\"Either one or two conditions are true!\")\nelif:\nprint(\"mmh..they must both be false\"\")\n```\n\n#### Answer\n\n::: {#083644c7 .cell execution_count=25}\n``` {.python .cell-code}\ncondition1 = 2 < 4\ncondition2 = (6/3) != 2\n\nif (condition1) or (condition2):\n    print(\"Either one or two conditions are true!\")\nelse:\n    print(\"mmh..they must both be false\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEither one or two conditions are true!\n```\n:::\n:::\n\n\n::::\n\n### NOT \n\nLastly, the `not` operator allows you to reverse (or invert, if you prefer) the value of a Boolean. So it turns a `True` into a `False` and vice-versa.\n\n:::{.to-pyodide}\n\n::: {#c7e32fc9 .cell execution_count=26}\n``` {.python .cell-code}\n# Like so:\nconditionInverted = not (2 == 2) # not turns True into False\nprint(conditionInverted)\n\n# And:\nconditionInverted = not (\"Foo\" == \"Bar\") # not turns False into True\nprint(conditionInverted)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\n```\n:::\n:::\n\n\n:::\n\n#### A challenge for you!\n\nCan you guess the result of this code _before_ you run it?\n\n:::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\nif not conditionInverted:\n   print(\"I'm True\")\nelif not (4%3  != 1):\n   print(\"2\")\nelse:\n   print(\"99\" == str(99)+1)\n```\n\n#### Answer\n\n::: {#58ef3eb3 .cell execution_count=27}\n``` {.python .cell-code}\nif not conditionInverted:\n   print(\"I'm True\")\nelif not (4%3  != 1):\n   print(\"2\")\nelse:\n   print(\"99\" == str(99)+1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n:::\n\n\n::::\n\n## Applied Geo-Example\n\nThe aim of the excercise is to build a program that allows a user to choose a given London borough from a list, and get in return both its total population and a link to a OpenStreetMap that pin points its location.\n\nWe are going to introduce a function called `input` that, as the name implies, takes an input from the user (interactively, that is!). We'll use it to interact with the user of our program. The input is going to be saved in a variable called `user_input`.\n\nI've provided a basic scaffolding of the code. It covers the case where the user choses the City borough, or provides an invalid input. Complete the script so that the three other boroughs can be found by the user.\n\nHINT: You will need to use `elif` statements to check for the various cases that use user might input.\n\n:::: {.panel-tabset}\n\n#### Question\n\n```{pyodide-python}\n# variable with the City borough's total population (in thousands)\ncity_of_London = 7.375\n# City borough's map marker\ncity_coords = \"http://www.openstreetmap.org/?mlat=51.5151&mlon=-0.0933#map=14/51.5151/-0.0933\"\n\n# Other boroughs\n# camden = 220.338\n# camden_coords = \"http://www.openstreetmap.org/?mlat=51.5424&mlon=-0.2252#map=12/51.5424/-0.2252\"\n# hackney = 246.270\n# hackney_coords = \"http://www.openstreetmap.org/?mlat=51.5432&mlon=-0.0709#map=13/51.5432/-0.0709\"\n# lambeth = 303.086\n# lambeth_coords = http://www.openstreetmap.org/?mlat=51.5013&mlon=-0.1172#map=13/51.5013/-0.1172\n\ntry:\n  # Let's ask the user for some input\n  # and store his answer\n  user_input = input(\"\"\"\n  Choose a neighbourhood by type the corresponding number:\n  1- City of London\n  2- Lambeth\n  3- Camden\n  4- Hackney\n  \"\"\")\nexcept OSError:\n  # We're running the browser most likely\n  user_input = '1'\n\n# Arbitrarily assign case 1 to City of London borough\n\nif (user_input == '1'):    \n    choosen_borough = city_of_London\n    borough_coordinates = city_coords \n    # print the output\n    # notice we are casting the user answer to string\n    print(\"You have choosen number : \"+ str(user_input))\n    print(\"The corresponding borough has a population of \"+ str(choosen_borough) +\" thousand people\")\n    print(\"Visit the borough by clicking here: \" + borough_coordinates)\n    # ---------------\n    # add more cases here...\n    # ---------------\nelse:\n    print(\"That's not in my system. Please try again!\")\n```\n\n#### Answer\n\n::: {#93742dd4 .cell execution_count=28}\n``` {.python .cell-code}\n# variable with the City borough's total population (in thousands)\ncity_of_London = 7.375\n# City borough's map marker\ncity_coords = \"http://www.openstreetmap.org/?mlat=51.5151&mlon=-0.0933#map=14/51.5151/-0.0933\"\n\n# Other boroughs\ncamden = 220.338\ncamden_coords = \"http://www.openstreetmap.org/?mlat=51.5424&mlon=-0.2252#map=12/51.5424/-0.2252\"\nhackney = 246.270\nhackney_coords = \"http://www.openstreetmap.org/?mlat=51.5432&mlon=-0.0709#map=13/51.5432/-0.0709\"\nlambeth = 303.086\nlambeth_coords = \"http://www.openstreetmap.org/?mlat=51.5013&mlon=-0.1172#map=13/51.5013/-0.1172\"\n\n# Let's ask the user for some input\n# and store his answer -- this doesn't\n# work in a non-interactive shell\ntry:\n  # Let's ask the user for some input\n  # and store his answer\n  user_input = input(\"\"\"\n  Choose a neighbourhood by type the corresponding number:\n  1- City of London\n  2- Lambeth\n  3- Camden\n  4- Hackney\n  \"\"\")\nexcept:\n  # We're running the browser most likely\n  user_input = '1'\n\n# Arbitrarily assign case 1 to City of London borough\n\nif (user_input == '1'):    \n    choosen_borough = city_of_London\n    borough_coordinates = city_coords \n    # print the output\n    # notice we are casting the user answer to string\n    print(\"You have choosen number : \"+ str(user_input))\n    print(\"The corresponding borough has a population of \"+ str(choosen_borough) +\" thousand people\")\n    print(\"Visit the borough by clicking here: \" + borough_coordinates)\nelif(user_input == '2'):    \n    choosen_borough = lambeth\n    borough_coordinates = lambeth_coords \n    # print the output\n    # notice we are casting the user answer to string\n    print(\"You have choosen number : \"+ str(user_input))\n    print(\"The corresponding borough has a population of \"+ str(choosen_borough) +\" thousand people\")\n    print(\"Visit the borough clicking here: \" + borough_coordinates)\nelif(user_input == '3'):    \n    choosen_borough = camden\n    borough_coordinates = camden_coords \n    # print the output\n    # notice we are casting the user answer to string\n    print(\"You have choosen number : \"+ str(user_input))\n    print(\"The corresponding borough has a population of \"+ str(choosen_borough) +\" thousand people\")\n    print(\"Visit the borough clicking here: \" + borough_coordinates)\nelif(user_input == '4'):    \n    choosen_borough = hackney\n    borough_coordinates = hackney_coords \n    # print the output\n    # notice we are casting the user answer to string\n    print(\"You have choosen number : \"+ str(user_input))\n    print(\"The corresponding borough has a population of \"+ str(choosen_borough) +\" thousand people\")\n    print(\"Visit the borough clicking here: \" + borough_coordinates)    \n    \nelse:\n    print(\"That's not in my system. Please try again!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nYou have choosen number : 1\nThe corresponding borough has a population of 7.375 thousand people\nVisit the borough by clicking here: http://www.openstreetmap.org/?mlat=51.5151&mlon=-0.0933#map=14/51.5151/-0.0933\n```\n:::\n:::\n\n\n::::\n\n### Credits!\n\n#### Contributors:\nThe following individuals have contributed to these teaching materials: \n- [James Millington](https://github.com/jamesdamillington)\n- [Jon Reades](https://github.com/jreades)\n- [Michele Ferretti](https://github.com/miccferr)\n\n#### License\nThe content and structure of this teaching project itself is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 license](https://creativecommons.org/licenses/by-nc-sa/4.0/) , and the contributing source code is licensed under [The MIT License](https://opensource.org/licenses/mit-license.php).\n\n#### Acknowledgements:\nSupported by the [Royal Geographical Society](https://www.rgs.org/HomePage.htm) (with the Institute of British Geographers) with a Ray Y Gildea Jr Award.\n\n#### Potential Dependencies:\nThis lesson may depend on the following libraries: None\n\n",
    "supporting": [
      "Boolean_Logic_files"
    ],
    "filters": [],
    "includes": {}
  }
}