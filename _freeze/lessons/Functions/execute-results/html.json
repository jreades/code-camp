{
  "hash": "e04444db8251b35e4fc78d26fcb6f3d3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Introduction to Functions\n---\n\nIn this lesson we'll cover *functions* in Python, a concept that you've already encountered but to which you've not yet been formally introduced. Now we're going to dig into this a little bit more because writing functions is where lazy programmers become good programmers.\n\nIn other words, as we saw with the concept of *iteration*, programmers are lazy and they tend want to avoid doing boring tasks over and over again. The idea is to avoid \"wasting time re-inventing the wheel\" and programmers have abbreviated this idea to the acronym **D.R.Y.** (Do not Repeat Yourself): if you are doing something more than once or twice, ask yourself if there's a way to encapsulate what you are doing in a function: you write the function _once_, and then _call_ it whenever you need to complete that task.\n\n![automate](../img/automate_all_the_things.jpeg)\n\nNaturally, **D.R.Y.** has its opposite: **W.E.T.** (We Enjoy Typing or Write Everything Twice). Dry is nearly always better than wet.\n\nEncapsulating regularly-used bits of code in functions has several advantages:\n* Your code is more readable: because you only have to write a function once and can then re-use it as many times as you like, your files are shorter.\n* Your code is easier to maintain: because you only have to write a function once, if you find a mistake in your code, you also only have to fix it in one place.\n* Your can code more quickly: things that you do a _lot_ can even be stuck in a separate file that you _import_ into your code so that your most-used functions are immediately available.\n\nBasically, a function is a way to _do_ something _to_ something in a portable, easy-to-use little bundle of code.\n\n## Functions 101\n\nWe've already met and used some functions, especially when we dealt with lists and dictionaries:\n\n```python\nmyList = [1,\"two\", False, 9.99]\nlen(myList) # A function\n```\n\n```python\nprint(myList) # A different function!\n```\n\n### Layout of a Function\n\nAs we briefly mentioned in another lesson, any 'word' followed by a set of parenthesis is a function. The 'word' is the function's *name*, and anything that you write within the parantheses are the function's inputs (also known as *parameters*). Like so:\n\n```python\n\nfunction_name(optional_parameter_1, optional_parameter_2, ...)\n\n```\n\nSo how do we create (*instantiate* in programming terms) a new function? Like everything else in Python, functions have specific rules that you have to follow for the computer to understand what you want it to do. In this case there are two separate steps: the *function definition* and the *function call*.\n\n### Function Definition\n\nThis is a function definition:\n```python\ndef myFirstFunc():\n    print(\"Nice to meet you!\")\n```\nLet's see what happened there:\n- We indicated that we wanted to _define_ (lazy version: `def`) a new function.\n- Right after `def` we gave the function a name: `myFirstFunc`.\n- After the new function's name there's the set of parenthesis and a colon.\n- The line(s) of the function are indented (just like a loop).\n\nThe reason for the indenting is the same as for a `while` loop or an `if` condition! It indicates to the Python interpreter that whatever is indented *belongs* to the function. Is like saying: \"Look man, I'm going to define this `myFirstFunc` function, and whatever is indented afterwards is part of the function\". That is what we call the *function's body*, and it's the full package of instructions that we want the computer to run every time we *call* the function. \n\n### Function Call\n\nCool, now that we have defined a function how do we use it? \n\nThe same that we do with 'built-in' functions like `print` and `len`; we *call* it by just typing:\n```python\nmyFirstFunct()\n```\nTry it yourself in the code cell below!\n\n```python\n# the function definition\ndef myFirstFunc():\n    print(\"Nice to meet you!\")\n\n# the function call\nmyFirstFunc()\n```\n\nNotice that the sequence of function **definiton** (`def`) *and then* function **call** (`function_name()`) is important! Think about it: how would Python know what we are referring to (i.e. what is the `myFirstFunc` it has to call?), if we haven't yet specified it?\n\nIt's the same as with variables: try to `print` one before you've defined it and Python will complain!\n\n```python\nprint(myVariable)\nmyVariable = \"Hallo Hallo!\"\n```\n\nReading (out loud!) the error message hopefully makes the error obvious...  Quite explicit, isn't it? :)\n\n```python\nmyVariable = \"Hallo Hallo!\"\nprint(myVariable)\n```\n\n### A challenge for you!\n\nDefine a new function called \"sunnyDay\" that prints the string \"What a lovely day!\"\n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\ndef sunnyDay():\n    print(\"What a lovely day!\")\n```\n:::\n\nNow define a function named \"gloomyDay\" that prints \"I hate rainy days!\" \n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\ndef gloomyDay():\n    print(\"I hate rainy days!\")\n```\n:::\n\nFinally, call the two functions you have defined so that \"I hate rainy days!\" is printed before \"What a lovely day!\"\n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\ngloomyDay()\nsunnyDay()\n```\n:::\n\n## Arguments\n\nThose are pretty basic functions, and as you might have noticed they all kind of do the same thing but are no shorter than the thing they replaced (a single print command). You will definetely need them though whenever you are using a function to process some *input* and *return* some *output*. In that case the paramters are inputs that you are *passing* to the function.\n\n```python\ndef myFunction( input_parameter ):\n# do something to the input\n    return input_parameter\n```\n\n```python\ndef printMyName( name ):\n    print(\"Hi! My name is: \" + name)\n\nprintMyName(\"Gerardus\")\n```\n\n### A challenge for you!\n\nWe've already defined `printMyName`, so you don't need to do that again. Just ask the function to print _your_ name!\n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\nprintMyName(\"James\")\n```\n:::\n\nA *little* more useful, right? If we had to print out name badges for a big conference, rather than typing \"Hi! My name is ...\" hundreds of times, if we had a list of people's names, we could just use a `for` loop to print out each one in turn using this function. The function adds the part that *is the same* for every name badge and all we need to do is pass it the input parameters. In fact, why don't we try that now?\n\n```python\nfor name in [\"Jon Reades\", \"James Millington\", \"Chen Zhong\", \"Naru Shiode\"]:\n    printMyName(name)\n```\n\nIn the function `printMyName` we used just one parameter as an input, but we are not constrained to just one. We can input many parameters *separated by commas*; let's _redefine_ the `printMyName` function:\n\n```python\ndef printMyName(name, surname):\n    print(\"Hi! My name is \"+ name + \" \" + surname)\n\nprintMyName(\"Gerardus\", \"Merkatoor\")\n```\n\nAnd now can pass input parameters to a function dynamically from a data structure within a loop: \n\n```python\nbritishProgrammers = [\n    [\"Babbage\", \"Charles\"],\n    [\"Lovelace\", \"Ada\"], \n    [\"Turing\", \"Alan\"],\n]\n\nfor p in britishProgrammers:\n    printMyName(p[1], p[0])\n```\n\nNeat right? We've simplified things to that we can focus only on what's important: we have our 'data structure' (the list-of-lists) and we have our printing function (`printMyName`). And now we just use a `for` loop to do the hard work. If we had 1,000 british programmers to print out it would be the *same* level of effort.\n\nSee what we mean about it being like Lego? We've combined a new concept with a concept covered in the last lesson to simplify the process of printing out nametags.\n\n### A challenge for you!\n\nDefine and use a function that takes as input parameters a `<name>` (String) and `<age>` (Integer) and then prints out the phrase: `<name> + \"is\" + <age> +\" years old\"`\n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\ndef printMyAge(name, age):\n    print(name + \" is \" + str(age) + \" years old.\")\n    \nprintMyAge('Jon',25)\n```\n:::\n\nThere's actually another way to do this that is quite helpful because it's easier to read:\n\n```python\ndef printMyAge(name, age):\n    print(f\"{name} is {age} years old.\") # This is called a 'f-string' and we use {...} to add variables\n    \nprintMyAge('Jon',25)\n```\n\n## Scoping\n\nNow I'd like you to focus on a particuarly important concept: something called 'scoping'. Notice that the names we are using for the parameters are *de facto* creating new variables that we then use in the *function body* (the indented block of code). In the example below, 'name' and 'surname' are _scoped_ to the body of the funciton. Outside of that block (outside of that scope) they don't exit!\n\nHere's the proof:\n\n```python\ndef whoAmI(myname, mysurname):\n    if not myname:\n        myname = 'Charles'\n    if not mysurname:\n        mysurname = 'Babbage'\n    print(\"Hi! My name is \"+ myname + \" \" + mysurname + \"!\")\n\nprint(myname) # myname _only_ exists 'inside' the function definition\n```\n\nNotice how the ErrorMessage is the same as before when we tried to `print` a variable that wasn't defined yet? It's the same concept: the variables defined as parameters exist only in the indented code block of the function (the [function *scope*](http://python-textbok.readthedocs.io/en/latest/Variables_and_Scope.html) ).\n\nBut notice too that if you replace `print name` with `whoAmI(\"Ada\", \"Lovelace\")` then the error disappears and you will see the output: \"Hi! My name is Ada Lovelace.\" So to reiterate: parameters to a function exist as variables **only within the function scope**.\n\n```python\nwhoAmI('Ada','Lovelace')\n```\n\n## Default Parameters\n\nLet's say that your namebade printing function is a worldwide hit, and while most conferences take place in English, in some cases they might need to say 'Hello' in a different languages. In this case, we might like to have a parameter with a _default_ value (\"Hi\") but allow the programmer to override that with a _different_ value (e.g. \"Bonjour\").\n\nHere's how that works:\n\n```python\ndef printInternational(name, surname, greeting=\"Hi\"):\n    print(greeting + \"! My name is \"+ name + \" \" + surname)\n\nprintInternational(\"Ada\", \"Lovelace\")\nprintInternational(\"Charles\", \"Babbage\")\nprintInternational(\"Laurent\", \"Ribardière\", \"Bonjour\")\nprintInternational(\"François\", \"Lionet\", \"Bonjour\")\nprintInternational(\"Alan\", \"Turing\")\nprintInternational(\"Harsha\",\"Suryanarayana\", \"Namaste\")\n```\n\nSo we only have to provide a value for a parameter with a default setting if we want to change it for some reason.\n\n## Return statement\n\nUp to here we've only had a function that printed out whatever we told it to. Of course, that's pretty limited and there are a lot of cases where we would want the function to do something and then come back to us with an answer! And remember that the problem of variable scoping means that variables declared inside a function aren't visible to the rest of the program.\n\nSo if you want to access a value calculated inside a function then you have to explicitely return it using the *reserved keyword* `return`:\n\n```python\ndef sumOf(firstQuantity, secondQuantity):\n    return firstQuantity + secondQuantity\n\nprint(sumOf(1,2))\nprint(sumOf(109845309234.30945098345,223098450985698054902309342.43598723900923489))\n```\n\n### Assigning to a Variable\n\nThe `return` keyword, somewhat obviously, returns whatever you tell it to so that that 'thing' become accessible outside of the function's scope. You can do whatever you want with the returned value, like assign it to a new variable:\n\n```python\nreturnedValue = sumOf(4, 3)\n\n# Notice the casting from int to str!\nprint(f\"This is the returned value: {returnedValue}\")\n```\n\nOne important thing to remember is that `return` always marks the end of the list of instructions in a function. So whatever code is written below `return` *and yet still indented in the function scope* won't be executed:\n\n```python\ndef genericFunc(parameter):\n    # do something to parameter\n    # ...\n    # do something else..\n    # ...\n    return \n    print(\"this line won't be ever executed! how sad!\")\n    print(\"nope. this won't either, sorry.\")\n```\n\n\n### A challenge for you!\n\nGuess which will be the highest number to be printed from this function (**think about your guess _before_ you execute the code)**:\n\n```python\ndef printNumbers():\n    print(2)\n    print(5)\n    return\n    print(9999)\n    print(800000)\n\nprintNumbers()\n```\n\n5 is the last value printed becayse a `return` statement ends the execution of the function, regardless of whether a result (i.e. a value following the `return` keyword _on the same line_ ) to the caller.\n\nNow that you have seen a bit more what is happening in a function, we can combine some concepts that we have seen in previous lessons to produce interesting bits of code. Take a look at how I've combined the `range` function, and the `for in` loop to print only the odd numbers for a given range.\n\n```python\ndef oddNumbers(inputRange):\n    \"\"\"\n    A function that prints only the odd numbers for a given range from 0 to inputRange.\n      inputRange - an integer representing the maximum of the range\n    \"\"\"\n    for i in range(inputRange):\n        if i%2 != 0:\n            print(i)\n\noddNumbers(10)\n\nprint(\"And...\")\n\noddNumbers(15)\n\nhelp(oddNumbers)\n```\n\nLet's take a closer look at what's happening above...\n```python\ndef oddNumbers(inputRange):\n    \"\"\"\n    A function that prints only the odd numbers for a given range from 0 to inputRange.\n      inputRange - an integer representing the maximum of the range\n    \"\"\"\n    for i in range(inputRange):\n        if i%2 != 0:\n            print(i)\n```\nThis defines a new function called `oddNumbers` which takes one parameter – it's not immediately clear what type of variable `inputRange` is, but we can guess it pretty quickly from what happens next.\n\nYou'll notice that there's are some lines immediately _after_ the function definition (between the triple-quotes) that aren't printed or obviously used, but that look like documentation of some sort. We'll come back to that in a minute.\n\nThe next line is a simple `for` loop: `for i in range(inputRange)`. The `range` function [generates](https://www.pythoncentral.io/pythons-range-function-explained/) a list of numbers from 0 to the input parameter passed to it. So we are going to be running a loop from 0 to *n* (where *n*=`inputRange`) and assigning the result of that to `i`.\n\nThe next line is nested inside the for loop: so we take _each_ `i` in turn and perform the modulo calculation on it: if `i%2` is `0` then `i` is divisble by 2. It's even. If it's not equal to `0` then it's not an even number, and in that case we'll print it out.\n\nWhich is exactly what happens with:\n```python\noddNumbers(10)\noddNumbers(15)\n```\n\nThe last line is something new:\n```python\nhelp(oddNumbers)\n```\nIf you look at the output of this, you'll see that it prints out the content we wrote into the triple-quotes in the function definition. So if you want to give your function some documentation that others can access, this is how you do it. In fact, this is how _every_ function in Python should be documented. \n\nTry these (and others) in the empty code block below:\n```python\nhelp(len)\nhelp(str)\nmyList = [1,2,3]\nhelp(myList.append)\n```\n\n```python\nhelp(len)\nmyList = [1,2,3]\nhelp(myList.append)\n```\n\n### A Challenge for you!\n\nNow modify the oddNumbers function so that it _also_ prints \"Yuck, an even number!\" for every even number...\n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\ndef oddNumbers(inputRange):\n    for i in range(inputRange):\n        if i%2 != 0:\n            print(i)\n        else:\n            print(\"Yuck, an even number!\")\n\noddNumbers(8)\n```\n:::\n\n## Functions as Parameters of Other Functions\n\nThis leads us to another intersting idea: since moving around functions is so easy, what happens when we use them as inputs to other functions?\n\n```python\ndef addTwo(param1):\n    return param1 + 2\n\ndef multiplyByThree(param1): # Note: this is a *separate* variable from the param1 in addTwo() because of scoping!\n    return param1 * 3\n\n# you can use multiplyByThree\n# with a regular argument as input     \nprint(multiplyByThree(2))\n\n# but also with a function as input\nprint(multiplyByThree(addTwo(2)))\n\n# And then\nprint(addTwo(multiplyByThree(2)))\n```\n\n## Applied Geo-example\n\nFor the last Geo-Example, let's revisit a couple of old exercises, combining them and making them a bit more sophisticated with the help of our newly acquired concept of functions.\n\nFirst, let's define some variables to contain data that we will then use with the functions.\n\n```python\n# London's total population\nlondon_pop = 7375000\n\n# list with some of London's borough. Feel free to add more! \nlondon_boroughs = {\n    \"City of London\": {\n     \"population\": 8072,\n     \"coordinates\" : [-0.0933, 51.5151]\n    },\n    \"Camden\": {\n     \"population\": 220338,\n     \"coordinates\" : [-0.2252,1.5424]\n    },\n    \"Hackney\": {\n     \"population\": 220338,\n     \"coordinates\" : [-0.0709, 51.5432]\n    },\n    \"Lambeth\": {\n     \"population\": 303086,\n     \"coordinates\" : [-0.1172,51.5013]\n    }\n}\n```\n\nNow, fix the code in the next cell to use the variables defined in the last cell. The `calcProportion` function should return the proportion of the population that the `boro` borough composes of London.  The `getLocation` function should return the coordinates of the `boro` borough. \n\n::: {.panel-tabset}\n#### Exercise\n```python\ndef calcProportion(boro,city_pop=???):\n    return ???['population']/???\n\ndef getLocation(???):\n    return boro[???]\n```\n#### Solution\n```python\n#in this function definition we provide a default value for city_pop\n#this makes sense here because we are only dealing with london\ndef calcProportion(boro,city_pop=7375000):\n    return boro['population']/city_pop\n\ndef getLocation(boro):\n    return boro['coordinates'] #returns the value for the `coordinates` key from the value for the `Lambeth` key\n```\n:::\n\nWrite some code to print the **longitude of Lambeth**. This could be done in a single line but don't stress if you need to use more lines... \n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\n#one-liner (see if you can understand how it works)\nprint(getLocation(london_boroughs['Lambeth'])[0])\n\n# A longer but possibly more user-friendly way:\ncoord = getLocation(london_boroughs['Lambeth'])\nlong  = coord[0]\nprint(long)\n```\n:::\n\nWrite some code to print the **proportion of the London population that lives in the City of London**. Using the function defined above, this should take only one line of code.\n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\nprint(calcProportion(london_boroughs['City of London']))\n```\n:::\n\nWrite code to loop over the `london_boroughs` dictionary, use the `calcProportion` and `getLocation` functions to then print proportions and locations of all the boroughs. \n\n::: {.panel-tabset}\n#### Exercise\n```python\n#your code here\n```\n#### Solution\n```python\nfor boro, data in london_boroughs.items():\n    prop = calcProportion(data)\n    location = getLocation(data)\n    \n    print(prop)\n    print(location)\n    print(\"\")\n    \n    #to print more nicely you could use string formatting:\n    #print(\"Proportion is {0:3.3f}%\".format(prop*100))\n    #print(\"Location of \" + boro + \" is \" + str(location))\n```\n:::\n\n\n### Further references:\n\nGeneral list or resources\n- [Awesome list of resources](https://github.com/vinta/awesome-python)\n- [Python Docs](https://docs.python.org/3/tutorial/introduction.html)\n- [HitchHiker's guide to Python](http://docs.python-guide.org/en/latest/intro/learning/)\n- [Learn Python the Hard Way - Lists](http://learnpythonthehardway.org/book/ex32.html)\n- [Learn Python the Hard Way - Dictionaries](http://learnpythonthehardway.org/book/ex39.html)\n\n### Credits!\n\n#### Contributors:\nThe following individuals have contributed to these teaching materials: \n- [James Millington](https://github.com/jamesdamillington)\n- [Jon Reades](https://github.com/jreades)\n- [Michele Ferretti](https://github.com/miccferr)\n\n#### License\nThe content and structure of this teaching project itself is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 license](https://creativecommons.org/licenses/by-nc-sa/4.0/), and the contributing source code is licensed under [The MIT License](https://opensource.org/licenses/mit-license.php).\n\n#### Acknowledgements:\nSupported by the [Royal Geographical Society](https://www.rgs.org/HomePage.htm) (with the Institute of British Geographers) with a Ray Y Gildea Jr Award.\n\n#### Potential Dependencies:\nThis lesson may depend on the following libraries: None\n\n",
    "supporting": [
      "Functions_files"
    ],
    "filters": [],
    "includes": {}
  }
}